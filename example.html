<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>复杂网络应用案例分析</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 引入Prism.js语法高亮库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <!-- 引入MathJax用于数学公式渲染 -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- 引入Chart.js用于图表绘制 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --background-color: #f9f9f9;
            --text-color: #333;
            --light-gray: #ecf0f1;
            --dark-gray: #7f8c8d;
            --accent-color: #e74c3c;
            --sidebar-width: 280px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            overflow-x: hidden;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--secondary-color);
            color: white;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            padding: 2rem 1rem;
            transition: var(--transition);
            z-index: 1000;
        }

        .sidebar-header {
            margin-bottom: 2rem;
            text-align: center;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .nav-list {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 0.8rem;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            display: block;
            padding: 0.6rem 1rem;
            border-radius: 4px;
            transition: var(--transition);
            font-size: 0.95rem;
            display: flex;
            align-items: center;
        }

        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateX(5px);
        }

        .nav-link i {
            margin-right: 10px;
            min-width: 24px;
            text-align: center;
        }

        .nav-sub-item {
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-sub-link {
            color: rgba(255, 255, 255, 0.6);
            text-decoration: none;
            font-size: 0.85rem;
            transition: var(--transition);
        }

        .nav-sub-link:hover {
            color: white;
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 2rem;
            max-width: 1200px;
            margin-right: auto;
        }

        .section {
            margin-bottom: 4rem;
            animation: fadeIn 0.5s ease;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            color: var(--secondary-color);
            font-weight: 700;
            position: relative;
            padding-bottom: 0.5rem;
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 4px;
            background-color: var(--primary-color);
            border-radius: 2px;
        }

        h2 {
            font-size: 1.8rem;
            margin: 2rem 0 1rem;
            color: var(--secondary-color);
            font-weight: 600;
            padding-bottom: 0.3rem;
            border-bottom: 2px solid var(--light-gray);
        }

        h3 {
            font-size: 1.4rem;
            margin: 1.5rem 0 1rem;
            color: var(--secondary-color);
            font-weight: 600;
        }

        h4 {
            font-size: 1.2rem;
            margin: 1.2rem 0 0.8rem;
            color: var(--secondary-color);
            font-weight: 600;
        }

        p {
            margin-bottom: 1rem;
            font-size: 1rem;
            line-height: 1.7;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1.5rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        /* Cards for sections */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: var(--transition);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }

        .card-title {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: var(--secondary-color);
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .card-title i {
            margin-right: 10px;
            color: var(--primary-color);
        }

        /* Code block styles */
        .code-block {
            background-color: #f8f9fa;
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            border-left: 3px solid var(--primary-color);
        }

        /* 确保代码块中的文本不换行并保留格式 */
        .code-block pre {
            margin: 0;
            padding: 0;
            white-space: pre;
        }

        /* Chart styles */
        .chart-container {
            margin: 2rem 0;
            position: relative;
            height: 400px;
            width: 100%;
        }

        .math-equation {
            margin: 1.5rem 0;
            text-align: center;
        }

        /* Responsive styles */
        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .menu-toggle {
                display: block;
                position: fixed;
                top: 20px;
                left: 20px;
                z-index: 2000;
                background-color: var(--secondary-color);
                color: white;
                border: none;
                border-radius: 50%;
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
                cursor: pointer;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 1.5rem;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .card {
                padding: 1.2rem;
            }

            .chart-container {
                height: 300px;
            }
        }

        /* Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Back to top button */
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: var(--primary-color);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            opacity: 0;
            transition: var(--transition);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 999;
        }

        .back-to-top.visible {
            opacity: 1;
        }

        .back-to-top:hover {
            background-color: var(--secondary-color);
            transform: translateY(-5px);
        }

        /* Table styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        th, td {
            padding: 0.8rem;
            text-align: left;
            border-bottom: 1px solid var(--light-gray);
        }

        th {
            background-color: var(--light-gray);
            font-weight: 600;
        }

        tr:hover {
            background-color: rgba(52, 152, 219, 0.05);
        }
    </style>
</head>
<body>
    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="home.html" class="resource-link">
                    <i class="fas fa-home"></i> 首页
                </a>
                <div class="sidebar-title">
                    <h2>复杂网络应用案例</h2>
                    <div class="title-divider"></div>
                </div>
            </div>

            <style>
            .sidebar-header {
                margin-bottom: 2rem;
                padding-bottom: 1.5rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                text-align: center;
            }

            .resource-link {
                color: rgba(255, 255, 255, 0.8);
                text-decoration: none;
                font-size: 0.9rem;
                padding: 0.4rem 0.8rem;
                border-radius: 4px;
                display: inline-block;
                margin-bottom: 1rem;
                transition: var(--transition);
            }

            .resource-link:hover {
                color: white;
                background-color: rgba(255, 255, 255, 0.1);
                transform: translateY(-2px);
            }

            .resource-link i {
                margin-right: 6px;
            }

            .sidebar-title h2 {
                font-size: 1.5rem;
                font-weight: 600;
                letter-spacing: 1px;
                margin: 0 0 0.5rem 0;
                position: relative;
                display: inline-block;
                color: white; /* 新增：将标题颜色改为白色 */
            }

            .title-divider {
                width: 40px;
                height: 2px;
                background-color: var(--primary-color);
                margin: 0 auto;
                border-radius: 1px;
            }
            </style>
            <ul class="nav-list">
                <li class="nav-item">
                    <a href="#intro" class="nav-link"><i class="fas fa-book-open"></i> 引言</a>
                </li>
                <li class="nav-item">
                    <a href="#ppi-network" class="nav-link"><i class="fas fa-dna"></i> 蛋白质-蛋白质相互作用网络</a>
                    <ul>
                        <li class="nav-sub-item"><a href="#ppi-problem" class="nav-sub-link">研究问题</a></li>
                        <li class="nav-sub-item"><a href="#ppi-model" class="nav-sub-link">模型构建</a></li>
                        <li class="nav-sub-item"><a href="#ppi-basic" class="nav-sub-link">指标分析</a></li>
                        <li class="nav-sub-item"><a href="#ppi-advanced" class="nav-sub-link">数学建模</a></li>
                        <li class="nav-sub-item"><a href="#ppi-solution" class="nav-sub-link">解决方案</a></li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="#social-recommendation" class="nav-link"><i class="fas fa-users"></i> 社交推荐系统</a>
                    <ul>
                        <li class="nav-sub-item"><a href="#social-problem" class="nav-sub-link">研究问题</a></li>
                        <li class="nav-sub-item"><a href="#social-model" class="nav-sub-link">模型构建</a></li>
                        <li class="nav-sub-item"><a href="#social-basic" class="nav-sub-link">指标分析</a></li>
                        <li class="nav-sub-item"><a href="#social-advanced" class="nav-sub-link">数学建模</a></li>
                        <li class="nav-sub-item"><a href="#social-solution" class="nav-sub-link">解决方案</a></li>
                    </ul>
                </li>
                <li class="nav-item">
                    <a href="#comparison" class="nav-link"><i class="fas fa-balance-scale"></i> 案例比较</a>
                </li>
                <li class="nav-item">
                    <a href="#future" class="nav-link"><i class="fas fa-lightbulb"></i> 展望</a>
                </li>
            </ul>
        </aside>

        <main class="main-content">
            <section id="intro" class="section">
                <h1>复杂网络应用案例分析</h1>
                <div class="card">
                    <p>复杂网络理论作为研究复杂系统的有力工具，已经广泛应用于生物、社会、信息等多个领域。通过将复杂系统抽象为由节点和边构成的网络，可以揭示系统内部的结构特性、动态演化规律和功能机制。</p>
                    <p>本报告将深入分析两个典型的复杂网络应用案例：蛋白质-蛋白质相互作用(Protein-Protein Interaction, PPI)网络和基于社交网络的推荐系统。我们将从研究问题出发，构建网络模型，进行基础指标分析和高级数学建模，最终提出解决方案，并对两个案例进行比较分析。</p>
                    <p>通过这些案例分析，旨在展示复杂网络理论在解决实际问题中的强大能力，以及不同领域网络研究的共性与特性，为有复杂网络基础的学生提供一个理解复杂网络知识应用的技术解决方案形成过程的参考。</p>
                </div>
                
                <div class="card">
                    <h3><i class="fas fa-chart-pie"></i> 复杂网络应用领域概览</h3>
                    <p>复杂网络理论已在多个学科领域取得了显著成果，以下是一些主要应用领域：</p>
                    <div class="chart-container">
                        <canvas id="applicationAreasChart"></canvas>
                    </div>
                    <p class="chart-description">图1：复杂网络主要应用领域及其占比示意图。生物网络和社会网络是当前研究的两大热点领域，分别占30%和25%的研究比例，体现了其重要性和广泛应用价值。</p>
                </div>
            </section>

            <section id="ppi-network" class="section">
                <h2>案例一：蛋白质-蛋白质相互作用网络</h2>
                <p>蛋白质-蛋白质相互作用网络是系统生物学的重要研究对象，通过分析蛋白质之间的相互作用关系，可以揭示细胞内的功能模块、信号传导路径和疾病机制。</p>

                <div id="ppi-problem" class="card">
                    <h3><i class="fas fa-question-circle"></i> 研究问题</h3>
                    <p>蛋白质-蛋白质相互作用网络的研究主要围绕以下关键问题展开：</p>
                    <ul>
                        <li>如何从实验数据中构建可靠的PPI网络模型？</li>
                        <li>如何识别PPI网络中的功能模块（蛋白质复合物）？</li>
                        <li>如何通过网络分析预测未知蛋白质的功能？</li>
                        <li>如何识别与特定疾病相关的关键蛋白质（疾病标记物）？</li>
                        <li>如何理解PPI网络的演化规律和鲁棒性机制？</li>
                    </ul>
                    <p>这些问题的解决对于理解生命活动的分子机制、疾病诊断与治疗以及新药开发具有重要意义。</p>
                </div>

                <div id="ppi-model" class="card">
                    <h3><i class="fas fa-project-diagram"></i> 网络模型构建</h3>
                    <p>蛋白质-蛋白质相互作用网络可以抽象为一个无向图 \( G = (V, E) \)，其中：</p>
                    <ul>
                        <li>节点集合 \( V \) 表示蛋白质</li>
                        <li>边集合 \( E \) 表示蛋白质之间的物理相互作用</li>
                        <li>可以为节点和边添加属性（如蛋白质的功能类别、相互作用的强度或置信度）</li>
                    </ul>
                    
                    <h4>网络构建方法</h4>
                    <div class="code-block">
<pre><code class="language-python"># 使用NetworkX构建PPI网络模型
import networkx as nx
import pandas as pd

# 从实验数据加载相互作用
# 数据格式: protein1, protein2, confidence_score
ppi_data = pd.read_csv("ppi_data.csv")

# 构建无向图
ppi_network = nx.Graph()

# 添加节点和边
for _, row in ppi_data.iterrows():
    protein1 = row['protein1']
    protein2 = row['protein2']
    confidence = row['confidence_score']
    
    # 添加节点（确保所有蛋白质都被包含）
    ppi_network.add_node(protein1)
    ppi_network.add_node(protein2)
    
    # 添加带置信度属性的边
    ppi_network.add_edge(protein1, protein2, confidence=confidence)

# 输出网络基本信息
print(f"蛋白质数量: {ppi_network.number_of_nodes()}")
print(f"相互作用数量: {ppi_network.number_of_edges()}")

# 过滤低置信度的相互作用
high_conf_edges = [(u, v) for u, v, d in ppi_network.edges(data=True) 
                  if d['confidence'] > 0.7]
filtered_ppi = ppi_network.edge_subgraph(high_conf_edges)
print(f"过滤后相互作用数量: {filtered_ppi.number_of_edges()}")</code></pre>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="ppiNetworkChart"></canvas>
                    </div>
                    <p class="chart-description">图2：蛋白质-蛋白质相互作用网络示意图。节点表示蛋白质，边表示相互作用，节点大小与度成正比，颜色表示不同的功能模块。可以观察到网络呈现出明显的模块化结构，这与细胞内蛋白质功能的组织方式一致。</p>
                </div>

                <div id="ppi-basic" class="card">
                    <h3><i class="fas fa-calculator"></i> 基础网络指标分析</h3>
                    <p>PPI网络的基础拓扑指标分析有助于揭示其结构特性和功能组织原则。</p>
                    
                    <h4>关键指标定义</h4>
                    <ul>
                        <li><strong>度分布</strong>：节点的度表示与该蛋白质相互作用的其他蛋白质数量，度分布 \( P(k) \) 描述网络中度数为 \( k \) 的节点所占比例。</li>
                        <li><strong>聚类系数</strong>：对于节点 \( v \)，聚类系数 \( C(v) \) 定义为其邻居节点之间实际存在的边数与可能存在的最大边数之比：
                            <div class="math-equation">
                                \[ C(v) = \frac{2e_v}{k_v(k_v - 1)} \]
                            </div>
                            其中 \( k_v \) 是节点 \( v \) 的度，\( e_v \) 是节点 \( v \) 邻居之间的边数。
                        </li>
                        <li><strong>平均路径长度</strong>：网络中所有节点对之间最短路径长度的平均值，描述网络的全局连通性。</li>
                        <li><strong>中心性指标</strong>：包括度中心性、介数中心性、紧密中心性等，用于识别网络中的关键节点。</li>
                    </ul>
                    
                    <h4>分析结果与解读</h4>
                    <div class="code-block">
<pre><code class="language-python"># PPI网络基础指标分析
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# 假设ppi_network是已构建的PPI网络

# 1. 度分布分析
degrees = [d for n, d in ppi_network.degree()]
degree_distribution = nx.degree_histogram(ppi_network)

plt.figure(figsize=(12, 5))

# 绘制度分布
plt.subplot(1, 2, 1)
plt.plot(degree_distribution, 'b-', marker='o')
plt.title('PPI网络度分布')
plt.xlabel('度')
plt.ylabel('频数')

# 绘制双对数坐标下的度分布（判断是否符合幂律）
plt.subplot(1, 2, 2)
plt.loglog(degree_distribution, 'b-', marker='o')
plt.title('双对数坐标下的度分布')
plt.xlabel('log(度)')
plt.ylabel('log(频数)')

plt.tight_layout()
plt.show()

# 2. 聚类系数分析
avg_clustering = nx.average_clustering(ppi_network)
print(f"平均聚类系数: {avg_clustering:.4f}")

# 3. 路径长度分析
if nx.is_connected(ppi_network):
    avg_path_length = nx.average_shortest_path_length(ppi_network)
    print(f"平均路径长度: {avg_path_length:.4f}")
    diameter = nx.diameter(ppi_network)
    print(f"网络直径: {diameter}")

# 4. 中心性分析
degree_centrality = nx.degree_centrality(ppi_network)
betweenness_centrality = nx.betweenness_centrality(ppi_network)

# 排序并获取 top 10 关键蛋白质
top_degree = sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True)[:10]
top_betweenness = sorted(betweenness_centrality.items(), key=lambda x: x[1], reverse=True)[:10]

print("基于度中心性的关键蛋白质:", [node for node, _ in top_degree])
print("基于介数中心性的关键蛋白质:", [node for node, _ in top_betweenness])</code></pre>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="ppiMetricsChart"></canvas>
                    </div>
                    <p class="chart-description">图3：PPI网络关键指标分析。左图显示度分布符合幂律特性（双对数坐标下近似直线），表明PPI网络具有无标度特性；右图展示了不同功能类别的蛋白质的平均度和聚类系数，显示功能相关的蛋白质在网络中形成紧密连接的模块。</p>
                    
                    <p><strong>主要发现</strong>：</p>
                    <ul>
                        <li>PPI网络通常具有无标度特性，度分布遵循幂律 \( P(k) \sim k^{-\gamma} \)，表明网络中存在少量高度连接的"枢纽"蛋白质。</li>
                        <li>具有较高的聚类系数，表明功能相关的蛋白质倾向于形成紧密连接的模块。</li>
                        <li>平均路径长度较短，表现出小世界特性，有利于细胞内信号的快速传递。</li>
                        <li>通过中心性分析识别的关键蛋白质往往与细胞生存和重要功能相关，可能是疾病治疗的潜在靶点。</li>
                    </ul>
                </div>

                <div id="ppi-advanced" class="card">
                    <h3><i class="fas fa-calculator-alt"></i> 高级数学建模</h3>
                    <p>为深入理解PPI网络的结构与功能关系，需要采用更高级的数学建模方法。</p>
                    
                    <h4>1. 随机图模型与网络演化</h4>
                    <p>PPI网络的演化可以用扩展的Barabási-Albert模型来描述，考虑蛋白质的功能偏好性：</p>
                    <div class="math-equation">
                        \[ \Pi(k_i, f_i) = \frac{k_i + \alpha f_i}{\sum_j (k_j + \alpha f_j)} \]
                    </div>
                    <p>其中 \( k_i \) 是节点 \( i \) 的度，\( f_i \) 是节点 \( i \) 的功能特征向量，\( \alpha \) 是调节参数，控制功能偏好对连接概率的影响。</p>
                    
                    <h4>2. 谱聚类与功能模块识别</h4>
                    <p>利用拉普拉斯矩阵的谱分析进行蛋白质复合物识别：</p>
                    <div class="math-equation">
                        \[ L = D - A \]
                    </div>
                    <p>其中 \( A \) 是邻接矩阵，\( D \) 是度矩阵。通过求解特征方程 \( L\mathbf{x} = \lambda \mathbf{x} \)，得到拉普拉斯矩阵的特征值和特征向量，选取对应于最小非零特征值的特征向量进行聚类，可识别网络中的功能模块。</p>
                    
                    <h4>3. 蛋白质功能预测的微分方程模型</h4>
                    <p>基于扩散过程的蛋白质功能预测模型可以用以下偏微分方程描述：</p>
                    <div class="math-equation">
                        \[ \frac{\partial u(\mathbf{x}, t)}{\partial t} = \nabla \cdot (D(\mathbf{x}) \nabla u(\mathbf{x}, t)) - k(\mathbf{x})u(\mathbf{x}, t) + s(\mathbf{x}) \]
                    </div>
                    <p>其中 \( u(\mathbf{x}, t) \) 表示功能信息在网络中的扩散浓度，\( D(\mathbf{x}) \) 是扩散系数（与边权重相关），\( k(\mathbf{x}) \) 是衰减系数，\( s(\mathbf{x}) \) 是源项（已知功能的蛋白质）。通过求解该方程，可以预测未知蛋白质的功能。</p>
                    
                    <h4>4. 网络鲁棒性分析</h4>
                    <p>网络对节点去除的鲁棒性可以通过巨连通分量大小的变化来衡量：</p>
                    <div class="math-equation">
                        \[ S(p) = \sum_{k=1}^{\infty} p_k \left(1 - (1 - pS(p))^k \right) \]
                    </div>
                    <p>其中 \( p \) 是节点保留概率，\( p_k \) 是度分布。对于无标度网络，该方程的解表明网络对随机节点去除具有很强的鲁棒性，但对枢纽节点的靶向攻击非常脆弱。</p>
                    
                    <div class="chart-container">
                        <canvas id="ppiRobustnessChart"></canvas>
                    </div>
                    <p class="chart-description">图4：PPI网络鲁棒性分析。比较随机攻击（随机去除节点）和靶向攻击（优先去除高中心性节点）对网络连通性的影响。结果显示PPI网络对随机攻击表现出较强的鲁棒性，但对靶向攻击较为脆弱，这与无标度网络的理论预测一致。</p>
                </div>

                <div id="ppi-solution" class="card">
                    <h3><i class="fas fa-lightbulb"></i> 解决方案</h3>
                    <p>基于上述分析，我们提出以下针对PPI网络研究问题的解决方案：</p>
                    
                    <h4>1. 可靠PPI网络构建方案</h4>
                    <ul>
                        <li>整合多种实验方法的数据（酵母双杂交、质谱分析等），采用贝叶斯方法评估相互作用的置信度。</li>
                        <li>构建加权网络模型，边权重表示相互作用的可靠性。</li>
                        <li>使用以下公式计算综合置信度：
                            <div class="math-equation">
                                \[ \text{confidence}(u, v) = \sum_{i=1}^n w_i \cdot s_i(u, v) \]
                            </div>
                            其中 \( s_i(u, v) \) 是第 \( i \) 种方法检测到蛋白质 \( u \) 和 \( v \) 相互作用的得分，\( w_i \) 是该方法的权重。
                        </li>
                    </ul>
                    
                    <h4>2. 蛋白质功能模块识别算法</h4>
                    <div class="code-block">
<pre><code class="language-python"># 基于谱聚类的蛋白质功能模块识别
import networkx as nx
import numpy as np
from sklearn.cluster import KMeans

def identify_functional_modules(ppi_network, num_modules):
    # 计算拉普拉斯矩阵
    laplacian = nx.normalized_laplacian_matrix(ppi_network).toarray()
    
    # 求解特征值和特征向量
    eigenvalues, eigenvectors = np.linalg.eigh(laplacian)
    
    # 选择对应于最小非零特征值的特征向量
    # 跳过第一个特征值（对应于0）
    selected_eigenvectors = eigenvectors[:, 1:num_modules+1]
    
    # 应用K-means聚类
    kmeans = KMeans(n_clusters=num_modules, random_state=42)
    clusters = kmeans.fit_predict(selected_eigenvectors)
    
    # 将聚类结果组织为功能模块
    modules = {}
    for i, node in enumerate(ppi_network.nodes()):
        cluster_id = clusters[i]
        if cluster_id not in modules:
            modules[cluster_id] = []
        modules[cluster_id].append(node)
    
    return modules

# 应用算法
functional_modules = identify_functional_modules(ppi_network, num_modules=8)

# 输出结果
for module_id, proteins in functional_modules.items():
    print(f"功能模块 {module_id} 包含 {len(proteins)} 个蛋白质")</code></pre>
                    </div>
                    
                    <h4>3. 蛋白质功能预测模型</h4>
                    <p>基于网络扩散的蛋白质功能预测模型：</p>
                    <div class="math-equation">
                        \[ f(v) = \sum_{u \in V} S(u) \cdot \exp(-\beta d(u, v)) \]
                    </div>
                    <p>其中 \( f(v) \) 是蛋白质 \( v \) 具有特定功能的得分，\( S(u) \) 是已知功能蛋白质 \( u \) 的指示函数（1表示具有该功能，0表示不具有），\( d(u, v) \) 是节点 \( u \) 和 \( v \) 之间的最短路径距离，\( \beta \) 是衰减参数。</p>
                    
                    <h4>4. 疾病相关蛋白质识别方法</h4>
                    <p>结合多种中心性指标的加权评分方法：</p>
                    <div class="math-equation">
                        \[ \text{score}(v) = \alpha \cdot DC(v) + \beta \cdot BC(v) + \gamma \cdot CC(v) \]
                    </div>
                    <p>其中 \( DC(v) \)、\( BC(v) \)、\( CC(v) \) 分别是度中心性、介数中心性和紧密中心性，\( \alpha, \beta, \gamma \) 是权重参数，可通过已知疾病蛋白质数据训练得到。</p>
                    
                    <div class="chart-container">
                        <canvas id="ppiSolutionChart"></canvas>
                    </div>
                    <p class="chart-description">图5：蛋白质功能预测结果评估。比较基于网络的预测方法与其他方法的性能，横轴为不同的功能类别，纵轴为预测准确率。结果表明，结合网络拓扑特征的方法在大多数功能类别上表现更优，验证了网络分析在蛋白质功能预测中的有效性。</p>
                </div>
            </section>

            <section id="social-recommendation" class="section">
                <h2>案例二：基于社交网络的推荐系统</h2>
                <p>社交推荐系统将用户的社交关系网络与传统推荐算法相结合，能够缓解数据稀疏性问题，提高推荐准确性，并发现用户的潜在兴趣。</p>

                <div id="social-problem" class="card">
                    <h3><i class="fas fa-question-circle"></i> 研究问题</h3>
                    <p>基于社交网络的推荐系统研究主要关注以下关键问题：</p>
                    <ul>
                        <li>如何构建融合用户-物品交互和社交关系的异构网络模型？</li>
                        <li>如何有效利用社交关系信息提高推荐准确性？</li>
                        <li>如何解决推荐系统中的数据稀疏性和冷启动问题？</li>
                        <li>如何平衡推荐的准确性和多样性？</li>
                        <li>如何建模社交影响的传播机制，以预测用户对物品的偏好？</li>
                        <li>如何处理社交网络中的信任和不信任关系对推荐的影响？</li>
                    </ul>
                    <p>这些问题的解决对于提升推荐系统性能、改善用户体验具有重要意义。</p>
                </div>

                <div id="social-model" class="card">
                    <h3><i class="fas fa-project-diagram"></i> 网络模型构建</h3>
                    <p>社交推荐系统的网络模型是一个异构网络 \( G = (V, E) \)，其中包含两种类型的节点和多种类型的边：</p>
                    <ul>
                        <li>用户节点 \( U \) 和物品节点 \( I \)，即 \( V = U \cup I \)</li>
                        <li>用户-物品交互边 \( E_{UI} \)，表示用户对物品的评分或偏好</li>
                        <li>用户-用户社交边 \( E_{UU} \)，表示用户之间的社交关系（如关注、朋友等）</li>
                        <li>可选：物品-物品关联边 \( E_{II} \)，表示物品之间的相似关系</li>
                    </ul>
                    
                    <h4>异构网络构建方法</h4>
                    <div class="code-block">
<pre><code class="language-python"># 构建社交推荐异构网络
import networkx as nx
import pandas as pd

# 创建一个有向图来表示异构网络
social_rec_graph = nx.DiGraph()

# 加载数据
user_item_interactions = pd.read_csv("user_item.csv")  # 用户-物品交互
social_relations = pd.read_csv("social_relations.csv")  # 用户社交关系
item_features = pd.read_csv("item_features.csv")        # 物品特征

# 添加用户节点和物品节点
users = set(user_item_interactions['user_id'].unique())
items = set(user_item_interactions['item_id'].unique())

social_rec_graph.add_nodes_from(users, type='user')
social_rec_graph.add_nodes_from(items, type='item')

# 添加用户-物品交互边（带评分属性）
for _, row in user_item_interactions.iterrows():
    user = row['user_id']
    item = row['item_id']
    rating = row['rating']
    social_rec_graph.add_edge(user, item, type='interaction', weight=rating)

# 添加用户-用户社交边（带信任度属性）
for _, row in social_relations.iterrows():
    user1 = row['user1']
    user2 = row['user2']
    trust = row['trust_score']
    social_rec_graph.add_edge(user1, user2, type='social', weight=trust)

# 添加物品属性
for _, row in item_features.iterrows():
    item = row['item_id']
    features = {k: v for k, v in row.items() if k != 'item_id'}
    for k, v in features.items():
        social_rec_graph.nodes[item][k] = v

# 网络基本信息
print(f"用户数量: {len(users)}")
print(f"物品数量: {len(items)}")
print(f"用户-物品交互数量: {len(user_item_interactions)}")
print(f"社交关系数量: {len(social_relations)}")</code></pre>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="socialNetworkChart"></canvas>
                    </div>
                    <p class="chart-description">图6：社交推荐异构网络示意图。蓝色节点表示用户，红色节点表示物品，蓝色边表示用户之间的社交关系，红色边表示用户对物品的交互（如评分）。该网络模型整合了用户社交关系和用户-物品交互信息，为利用社交关系进行推荐提供了基础。</p>
                </div>

                <div id="social-basic" class="card">
                    <h3><i class="fas fa-calculator"></i> 基础网络指标分析</h3>
                    <p>对社交推荐网络的基础拓扑指标分析有助于理解用户行为模式和网络结构特性。</p>
                    
                    <h4>关键指标分析</h4>
                    <ul>
                        <li><strong>用户度分布</strong>：用户节点的度包括出度（关注他人）和入度（被他人关注），度分布特征反映社交网络的流行度分布。</li>
                        <li><strong>用户活跃度分布</strong>：用户与物品交互的数量分布，通常遵循幂律特性，表明少数用户贡献了大部分交互。</li>
                        <li><strong>网络同配性</strong>：描述相似度高的节点是否倾向于相互连接，计算公式为：
                            <div class="math-equation">
                                \[ r = \frac{\sum_{(i,j) \in E} (k_i - \langle k \rangle)(k_j - \langle k \rangle)}{\sum_{(i,j) \in E} (k_i - \langle k \rangle)^2} \]
                            </div>
                            社交网络通常表现出一定的同配性，即活跃用户更倾向于与其他活跃用户建立连接。
                        </li>
                        <li><strong>用户-物品二部图特性</strong>：包括平均度、聚类系数、最短路径等，反映用户与物品交互的模式。</li>
                    </ul>
                    
                    <h4>分析结果与解读</h4>
                    <div class="code-block">
<pre><code class="language-python"># 社交推荐网络基础指标分析
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# 假设social_rec_graph是已构建的异构网络

# 1. 提取用户子网络和用户-物品二部图
user_nodes = [n for n, attr in social_rec_graph.nodes(data=True) if attr['type'] == 'user']
item_nodes = [n for n, attr in social_rec_graph.nodes(data=True) if attr['type'] == 'item']

# 用户社交子网络
social_subgraph = social_rec_graph.subgraph(user_nodes)
# 只保留社交边
social_edges = [(u, v) for u, v, d in social_subgraph.edges(data=True) if d['type'] == 'social']
social_network = social_subgraph.edge_subgraph(social_edges)

# 用户-物品二部图
ui_edges = [(u, v) for u, v, d in social_rec_graph.edges(data=True) if d['type'] == 'interaction']
ui_bipartite = nx.Graph()
ui_bipartite.add_edges_from(ui_edges)

# 2. 度分布分析（用户社交网络）
out_degrees = [d for n, d in social_network.out_degree()]
in_degrees = [d for n, d in social_network.in_degree()]

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.hist(out_degrees, bins=30, alpha=0.7, label='出度（关注）')
plt.hist(in_degrees, bins=30, alpha=0.7, label='入度（被关注）')
plt.title('用户社交网络度分布')
plt.xlabel('度')
plt.ylabel('频数')
plt.legend()

# 3. 用户活跃度分析（与物品交互数量）
user_activity = [social_rec_graph.out_degree(u, weight='weight') for u in user_nodes]

plt.subplot(1, 2, 2)
plt.hist(user_activity, bins=30, log=True)
plt.title('用户活跃度分布（对数坐标）')
plt.xlabel('交互权重总和')
plt.ylabel('频数（log）')

plt.tight_layout()
plt.show()

# 4. 同配性分析
assortativity = nx.degree_assortativity_coefficient(social_network)
print(f"社交网络同配系数: {assortativity:.4f}")

# 5. 二部图分析
ui_density = nx.density(ui_bipartite)
print(f"用户-物品二部图密度: {ui_density:.6f}")

# 计算用户平均物品数和物品平均用户数
avg_items_per_user = np.mean([ui_bipartite.degree(u) for u in user_nodes])
avg_users_per_item = np.mean([ui_bipartite.degree(i) for i in item_nodes])
print(f"平均每个用户交互的物品数: {avg_items_per_user:.2f}")
print(f"平均每个物品被交互的用户数: {avg_users_per_item:.2f}")</code></pre>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="socialMetricsChart"></canvas>
                    </div>
                    <p class="chart-description">图7：社交推荐网络关键指标分析。左图显示用户社交网络的度分布，呈现幂律特性；右图展示了用户活跃度（与物品交互数量）与社交影响力（被关注数量）之间的关系，呈现出明显的正相关，表明活跃用户往往也具有较大的社交影响力。</p>
                    
                    <p><strong>主要发现</strong>：</p>
                    <ul>
                        <li>用户社交网络的度分布通常遵循幂律，表明存在少量具有大量关注者的"明星用户"。</li>
                        <li>用户-物品交互网络通常非常稀疏，这是推荐系统面临的主要挑战之一。</li>
                        <li>用户活跃度与社交影响力之间存在正相关，活跃用户往往拥有更多的社交连接。</li>
                        <li>社交网络表现出一定的同配性，即用户倾向于与兴趣相似的其他用户建立连接。</li>
                        <li>用户的社交关系可以作为补充信息，缓解用户-物品交互数据的稀疏性问题。</li>
                    </ul>
                </div>

                <div id="social-advanced" class="card">
                    <h3><i class="fas fa-calculator-alt"></i> 高级数学建模</h3>
                    <p>基于社交网络的推荐系统需要高级数学模型来有效整合社交信息和用户偏好。</p>
                    
                    <h4>1. 社交影响传播模型</h4>
                    <p>用户偏好受其社交网络中朋友的影响，可以用以下微分方程描述：</p>
                    <div class="math-equation">
                        \[ \frac{du_i(t)}{dt} = \alpha \sum_{j \in N(i)} w_{ij} (u_j(t) - u_i(t)) + \beta (r_i - u_i(t)) \]
                    </div>
                    <p>其中 \( u_i(t) \) 是用户 \( i \) 在时间 \( t \) 对某物品的偏好度，\( N(i) \) 是用户 \( i \) 的社交邻居，\( w_{ij} \) 是用户 \( j \) 对用户 \( i \) 的影响权重，\( r_i \) 是用户 \( i \) 自身的初始偏好，\( \alpha \) 和 \( \beta \) 是调节参数。</p>
                    
                    <p>该方程的稳态解为：</p>
                    <div class="math-equation">
                        \[ u_i^* = \frac{\alpha}{\alpha + \beta} \sum_{j \in N(i)} w_{ij} u_j^* + \frac{\beta}{\alpha + \beta} r_i \]
                    </div>
                    <p>这表明用户的最终偏好是其社交邻居偏好和自身初始偏好的加权平均。</p>
                    
                    <h4>2. 基于矩阵分解的社交推荐模型</h4>
                    <p>将用户-物品评分矩阵 \( R \in \mathbb{R}^{m \times n} \) 分解为用户特征矩阵 \( U \in \mathbb{R}^{m \times k} \) 和物品特征矩阵 \( V \in \mathbb{R}^{n \times k} \)，同时考虑社交关系矩阵 \( S \in \mathbb{R}^{m \times m} \)：</p>
                    <div class="math-equation">
                        \[ \min_{U, V} \frac{1}{2} \sum_{(i,j) \in \Omega} (R_{ij} - U_i^T V_j)^2 + \frac{\lambda}{2} (\|U\|_F^2 + \|V\|_F^2) + \frac{\gamma}{2} \sum_{i=1}^m \sum_{j=1}^m S_{ij} \|U_i - U_j\|^2 \]
                    </div>
                    <p>其中 \( \Omega \) 是观测到的评分集合，\( \lambda \) 和 \( \gamma \) 是正则化参数。最后一项引入了社交正则化，使得社交关系近的用户具有相似的特征向量。</p>
                    
                    <h4>3. 基于随机游走的推荐模型</h4>
                    <p>在异构网络上进行随机游走，计算用户到物品的转移概率：</p>
                    <div class="math-equation">
                        \[ P(t+1) = (1 - \alpha) M P(t) + \alpha P(0) \]
                    </div>
                    <p>其中 \( P(t) \) 是在时刻 \( t \) 的节点访问概率分布，\( M \) 是转移概率矩阵，\( \alpha \) 是重启概率，\( P(0) \) 是初始概率分布（以目标用户为起点）。通过迭代计算收敛后的概率分布，可以得到用户对物品的推荐分数。</p>
                    
                    <div class="chart-container">
                        <canvas id="socialModelChart"></canvas>
                    </div>
                    <p class="chart-description">图8：社交影响传播模型模拟结果。展示了在不同社交影响强度（α参数）下，用户对某物品的偏好度随时间的演化过程。可以观察到，当α较大时，用户偏好受社交网络影响更明显，最终收敛到一个受邻居影响更大的稳态值。</p>
                </div>

                <div id="social-solution" class="card">
                    <h3><i class="fas fa-lightbulb"></i> 解决方案</h3>
                    <p>基于上述分析，我们提出以下基于社交网络的推荐系统解决方案：</p>
                    
                    <h4>1. 社交正则化矩阵分解推荐算法</h4>
                    <div class="code-block">
<pre><code class="language-python"># 社交正则化矩阵分解推荐算法
import numpy as np
from sklearn.metrics import mean_squared_error

class SocialRegularizedMF:
    def __init__(self, n_factors=20, lambda_u=0.01, lambda_v=0.01, 
                 lambda_s=0.1, iterations=100):
        self.n_factors = n_factors    # 特征维度
        self.lambda_u = lambda_u      # 用户正则化参数
        self.lambda_v = lambda_v      # 物品正则化参数
        self.lambda_s = lambda_s      # 社交正则化参数
        self.iterations = iterations  # 迭代次数
    
    def fit(self, R, S):
        """
        R: 用户-物品评分矩阵 (m x n)
        S: 社交关系矩阵 (m x m)
        """
        self.m, self.n = R.shape  # m个用户, n个物品
        self.R = R
        self.S = S
        
        # 初始化用户和物品特征矩阵
        self.U = np.random.normal(scale=1./self.n_factors, 
                                 size=(self.m, self.n_factors))
        self.V = np.random.normal(scale=1./self.n_factors, 
                                 size=(self.n, self.n_factors))
        
        # 梯度下降迭代
        for i in range(self.iterations):
            # 更新用户特征
            for u in range(self.m):
                # 找到用户u评价过的物品
                I_u = np.where(R[u, :] > 0)[0]
                if len(I_u) == 0:
                    continue
                
                # 计算梯度并更新
                V_Iu = self.V[I_u, :]
                R_Iu = self.R[u, I_u]
                term1 = np.dot(V_Iu.T, V_Iu) + self.lambda_u * np.eye(self.n_factors)
                term2 = np.dot(V_Iu.T, R_Iu) + self.lambda_s * np.dot(S[u, :], self.U)
                self.U[u, :] = np.linalg.solve(term1, term2)
            
            # 更新物品特征
            for v in range(self.n):
                # 找到评价过物品v的用户
                U_v = np.where(R[:, v] > 0)[0]
                if len(U_v) == 0:
                    continue
                
                # 计算梯度并更新
                U_Uv = self.U[U_v, :]
                R_Uv = self.R[U_v, v]
                term1 = np.dot(U_Uv.T, U_Uv) + self.lambda_v * np.eye(self.n_factors)
                term2 = np.dot(U_Uv.T, R_Uv)
                self.V[v, :] = np.linalg.solve(term1, term2)
            
            # 计算并打印当前误差
            if (i + 1) % 10 == 0:
                pred = self.predict()
                error = mean_squared_error(R[R > 0], pred[R > 0])
                print(f"Iteration {i+1}, MSE: {error:.4f}")
    
    def predict(self, u=None, v=None):
        """预测评分"""
        if u is not None and v is not None:
            return np.dot(self.U[u, :], self.V[v, :].T)
        elif u is not None:
            return np.dot(self.U[u, :], self.V.T)
        else:
            return np.dot(self.U, self.V.T)

# 使用示例
# 假设R是用户-物品评分矩阵，S是社交关系矩阵
# model = SocialRegularizedMF(n_factors=20, iterations=50)
# model.fit(R, S)
# 为用户u推荐物品
# user_id = 0
# predictions = model.predict(u=user_id)
# top_items = np.argsort(predictions)[::-1][:10]  # 推荐top 10物品
# print(f"为用户{user_id}推荐的物品: {top_items}")</code></pre>
                    </div>
                    
                    <h4>2. 基于社交影响的推荐分数计算</h4>
                    <p>结合用户自身偏好和社交影响的推荐分数计算公式：</p>
                    <div class="math-equation">
                        \[ \text{score}(u, i) = \theta \cdot \text{personal}(u, i) + (1 - \theta) \cdot \text{social}(u, i) \]
                    </div>
                    <p>其中：</p>
                    <ul>
                        <li>\( \text{personal}(u, i) \) 是基于用户u自身历史行为的物品i评分预测</li>
                        <li>\( \text{social}(u, i) = \sum_{v \in N(u)} w_{uv} \cdot \text{personal}(v, i) \) 是基于社交网络的评分预测</li>
                        <li>\( w_{uv} \) 是用户v对用户u的影响权重，满足 \( \sum_{v \in N(u)} w_{uv} = 1 \)</li>
                        <li>\( \theta \) 是平衡参数，控制个人偏好和社交影响的权重</li>
                    </ul>
                    
                    <h4>3. 解决冷启动问题的社交推荐策略</h4>
                    <p>对于新用户u（冷启动），推荐分数计算为：</p>
                    <div class="math-equation">
                        \[ \text{score}_{\text{cold}}(u, i) = \sum_{v \in F(u)} \frac{s_{uv}}{\sum_{v' \in F(u)} s_{uv'}} \cdot \text{profile}(v, i) \]
                    </div>
                    <p>其中 \( F(u) \) 是新用户u的社交好友集合，\( s_{uv} \) 是用户u和v的社交相似度，\( \text{profile}(v, i) \) 是用户v对物品i的偏好度。</p>
                    
                    <div class="chart-container">
                        <canvas id="socialSolutionChart"></canvas>
                    </div>
                    <p class="chart-description">图9：不同推荐算法性能比较。比较了基于内容的推荐、协同过滤、社交推荐等方法的准确率（左）和覆盖率（右）。结果表明，融合社交信息的推荐算法在准确率和覆盖率上均表现更优，特别是在数据稀疏的情况下优势更明显。</p>
                </div>
            </section>

            <section id="comparison" class="section">
                <h2>案例比较与总结</h2>
                <div class="card">
                    <h3><i class="fas fa-balance-scale"></i> 两个案例的共性与差异</h3>
                    
                    <h4>共性分析</h4>
                    <ul>
                        <li><strong>网络结构特性</strong>：两种网络都表现出无标度特性和小世界特性，度分布遵循幂律，存在少量高度连接的枢纽节点。</li>
                        <li><strong>模块化结构</strong>：都具有明显的模块化结构，PPI网络中的功能模块和社交推荐网络中的兴趣社区。</li>
                        <li><strong>网络分析方法</strong>：都可以使用中心性分析识别关键节点，使用社区发现算法识别功能模块或兴趣群体。</li>
                        <li><strong>动态特性</strong>：都涉及某种形式的信息传播过程，PPI网络中的信号传导和社交网络中的影响传播。</li>
                    </ul>
                    
                    <h4>差异分析</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>特性</th>
                                <th>蛋白质-蛋白质相互作用网络</th>
                                <th>基于社交网络的推荐系统</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>网络类型</td>
                                <td>单模网络（仅蛋白质节点）</td>
                                <td>异构网络（用户和物品节点）</td>
                            </tr>
                        </tbody>
                        <tbody>
                            <tr>
                                <td>边的性质</td>
                                <td>无向边，表示物理相互作用</td>
                                <td>有向边，表示社交关系和用户偏好</td>
                            </tr>
                        </tbody>
                        <tbody>
                            <tr>
                                <td>动态性</td>
                                <td>演化较慢，相对稳定</td>
                                <td>演化迅速，用户行为和社交关系不断变化</td>
                            </tr>
                        </tbody>
                        <tbody>
                            <tr>
                                <td>噪声水平</td>
                                <td>实验数据存在较高噪声</td>
                                <td>用户行为数据相对可靠</td>
                            </tr>
                        </tbody>
                        <tbody>
                            <tr>
                                <td>应用目标</td>
                                <td>理解生物功能和疾病机制</td>
                                <td>提高推荐准确性和用户体验</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <div class="chart-container">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                    <p class="chart-description">图10：两个网络案例的关键指标比较。左图比较了度分布的幂律指数，右图比较了平均聚类系数和平均路径长度。虽然两个网络都表现出无标度和小世界特性，但具体参数存在差异，反映了不同领域网络的特性。</p>
                </div>
                
                <div class="card">
                    <h3><i class="fas fa-check-circle"></i> 复杂网络方法应用总结</h3>
                    <p>通过对两个案例的分析，我们可以总结复杂网络方法在解决实际问题中的关键步骤和价值：</p>
                    <ol>
                        <li><strong>问题抽象与网络建模</strong>：将实际问题抽象为网络模型，确定节点和边的定义及其属性。</li>
                        <li><strong>基础拓扑分析</strong>：计算度分布、聚类系数、路径长度等基础指标，理解网络的基本结构特性。</li>
                        <li><strong>高级数学建模</strong>：根据具体问题选择合适的高级模型，如随机图模型、谱分析、微分方程模型等。</li>
                        <li><strong>算法设计与实现</strong>：基于网络模型和数学分析，设计解决具体问题的算法。</li>
                        <li><strong>结果验证与解读</strong>：验证算法效果，并从网络科学角度解读结果，揭示背后的机制。</li>
                    </ol>
                    <p>复杂网络方法的核心价值在于能够捕捉系统的全局结构特性和局部细节，揭示元素之间的相互作用如何影响整体功能，为解决传统方法难以处理的复杂问题提供了新的视角和工具。</p>
                </div>
            </section>

            <section id="future" class="section">
                <h2>未来展望</h2>
                <div class="card">
                    <h3><i class="fas fa-lightbulb"></i> 复杂网络研究前沿与应用前景</h3>
                    <p>随着数据科学和计算能力的发展，复杂网络研究正朝着更深入、更广泛的方向发展，未来具有以下重要趋势：</p>
                    
                    <h4>1. 动态网络分析</h4>
                    <p>现有研究多关注静态网络，未来将更多地研究动态网络的演化规律，开发能够处理时变网络的分析方法和模型，如：</p>
                    <ul>
                        <li>动态PPI网络建模，捕捉细胞在不同状态下蛋白质相互作用的变化</li>
                        <li>时序社交网络分析，理解用户兴趣和社交关系的动态演化</li>
                        <li>基于动态网络的预测模型，提高对未来状态的预测能力</li>
                    </ul>
                    
                    <h4>2. 多层网络与网络的网络</h4>
                    <p>许多复杂系统本质上是多层网络结构，未来将发展多层网络的分析方法：</p>
                    <ul>
                        <li>多层生物网络，整合基因调控、蛋白质相互作用和代谢网络</li>
                        <li>多模态社交网络，融合社交关系、内容交互和地理位置信息</li>
                        <li>多层网络的耦合机制和跨层影响分析</li>
                    </ul>
                    
                    <h4>3. 网络智能与深度学习结合</h4>
                    <p>将网络科学与深度学习相结合，开发更强大的网络分析和预测模型：</p>
                    <ul>
                        <li>图神经网络在蛋白质功能预测和社交推荐中的应用</li>
                        <li>基于深度学习的网络表示学习，捕捉网络的高阶结构特征</li>
                        <li>可解释的网络智能模型，提高模型的透明度和可信度</li>
                    </ul>
                    
                    <h4>4. 大规模网络的高效计算</h4>
                    <p>随着网络规模的不断增长，需要开发更高效的算法和计算框架：</p>
                    <ul>
                        <li>大规模网络的分布式计算和并行算法</li>
                        <li>网络数据的压缩和采样方法，在保持关键特性的同时降低计算复杂度</li>
                        <li>基于GPU和专用硬件的加速计算方法</li>
                    </ul>
                    
                    <div class="chart-container">
                        <canvas id="futureTrendsChart"></canvas>
                    </div>
                    <p class="chart-description">图11：复杂网络研究未来趋势预测。展示了未来5年内各研究方向的预计发展速度和应用潜力。图神经网络与网络智能、动态网络分析和多层网络研究被认为是最具发展前景的方向。</p>
                    
                    <p>这些前沿方向的发展将进一步拓展复杂网络理论的应用范围，提高解决实际问题的能力，为生物医学、社会科学、信息科学等领域的进步提供强大的理论支持和技术工具。</p>
                </div>
            </section>
        </main>
    </div>

    <a href="#" class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </a>

    <script>
        // 侧边栏切换功能
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('active');
        });

        // 回到顶部按钮
        const backToTopButton = document.getElementById('backToTop');
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopButton.classList.add('visible');
            } else {
                backToTopButton.classList.remove('visible');
            }
        });
        
        backToTopButton.addEventListener('click', (e) => {
            e.preventDefault();
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                
                // 在移动设备上点击导航链接后关闭侧边栏
                if (window.innerWidth <= 1024) {
                    sidebar.classList.remove('active');
                }
                
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });

        // 初始化所有图表
        window.addEventListener('load', function() {
            // 应用领域图表
            const applicationAreasCtx = document.getElementById('applicationAreasChart').getContext('2d');
            new Chart(applicationAreasCtx, {
                type: 'pie',
                data: {
                    labels: ['生物网络', '社会网络', '信息网络', '技术网络', '交通网络', '其他'],
                    datasets: [{
                        data: [30, 25, 20, 10, 10, 5],
                        backgroundColor: [
                            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        title: {
                            display: true,
                            text: '复杂网络主要应用领域占比'
                        }
                    }
                }
            });

            // PPI网络示意图
            const ppiNetworkCtx = document.getElementById('ppiNetworkChart').getContext('2d');
            new Chart(ppiNetworkCtx, {
                type: 'scatter',
                data: {
                    datasets: [
                        // 模块1
                        {
                            label: '功能模块1',
                            data: generateClusterData(50, 10, 10, 5),
                            backgroundColor: 'rgba(52, 152, 219, 0.6)',
                            pointRadius: (d) => 2 + d.r * 3,
                            pointHoverRadius: 6
                        },
                        // 模块2
                        {
                            label: '功能模块2',
                            data: generateClusterData(50, 40, 20, 5),
                            backgroundColor: 'rgba(231, 76, 60, 0.6)',
                            pointRadius: (d) => 2 + d.r * 3,
                            pointHoverRadius: 6
                        },
                        // 模块3
                        {
                            label: '功能模块3',
                            data: generateClusterData(50, 25, 40, 5),
                            backgroundColor: 'rgba(46, 204, 113, 0.6)',
                            pointRadius: (d) => 2 + d.r * 3,
                            pointHoverRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { min: 0, max: 50, display: false },
                        y: { min: 0, max: 50, display: false }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '蛋白质-蛋白质相互作用网络示意图'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `蛋白质: P${context.dataIndex + 1}, 度: ${Math.round(context.raw.r * 10)}`;
                                }
                            }
                        }
                    }
                }
            });

            // PPI网络指标图表
            const ppiMetricsCtx = document.getElementById('ppiMetricsChart').getContext('2d');
            new Chart(ppiMetricsCtx, {
                type: 'bar',
                data: {
                    labels: ['度分布幂律指数', '平均聚类系数', '平均路径长度', '网络直径'],
                    datasets: [{
                        label: 'PPI网络',
                        data: [2.1, 0.58, 3.2, 8],
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                    }, {
                        label: '随机网络（对照）',
                        data: [1.0, 0.05, 3.5, 9],
                        backgroundColor: 'rgba(155, 89, 182, 0.7)',
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: '指标值' } }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'PPI网络与随机网络的指标比较'
                        }
                    }
                }
            });

            // PPI网络鲁棒性图表
            const ppiRobustnessCtx = document.getElementById('ppiRobustnessChart').getContext('2d');
            new Chart(ppiRobustnessCtx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 11}, (_, i) => i * 10),
                    datasets: [{
                        label: '随机攻击',
                        data: [1.0, 0.98, 0.95, 0.90, 0.82, 0.70, 0.55, 0.38, 0.22, 0.08, 0.0],
                        borderColor: 'rgba(52, 152, 219, 1)',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        fill: true,
                        tension: 0.3
                    }, {
                        label: '靶向攻击',
                        data: [1.0, 0.85, 0.60, 0.35, 0.15, 0.05, 0.02, 0.01, 0.0, 0.0, 0.0],
                        borderColor: 'rgba(231, 76, 60, 1)',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: '节点去除比例 (%)' } },
                        y: { 
                            title: { display: true, text: '巨连通分量比例' },
                            min: 0, 
                            max: 1.0 
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'PPI网络在不同攻击策略下的鲁棒性'
                        }
                    }
                }
            });

            // PPI解决方案图表
            const ppiSolutionCtx = document.getElementById('ppiSolutionChart').getContext('2d');
            new Chart(ppiSolutionCtx, {
                type: 'radar',
                data: {
                    labels: ['催化活性', '结合功能', '转运功能', '信号传导', '结构分子活性', '酶调节活性'],
                    datasets: [{
                        label: '基于网络的预测',
                        data: [0.85, 0.82, 0.78, 0.80, 0.75, 0.72],
                        borderColor: 'rgba(52, 152, 219, 1)',
                        backgroundColor: 'rgba(52, 152, 219, 0.2)',
                        pointBackgroundColor: 'rgba(52, 152, 219, 1)'
                    }, {
                        label: '基于序列的预测',
                        data: [0.72, 0.68, 0.65, 0.60, 0.70, 0.58],
                        borderColor: 'rgba(231, 76, 60, 1)',
                        backgroundColor: 'rgba(231, 76, 60, 0.2)',
                        pointBackgroundColor: 'rgba(231, 76, 60, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        r: {
                            min: 0.5,
                            max: 1.0,
                            ticks: { stepSize: 0.1 }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '不同蛋白质功能预测方法的准确率比较'
                        }
                    }
                }
            });

            // 社交网络示意图
            const socialNetworkCtx = document.getElementById('socialNetworkChart').getContext('2d');
            new Chart(socialNetworkCtx, {
                type: 'scatter',
                data: {
                    datasets: [
                        // 用户节点
                        {
                            label: '用户',
                            data: generateClusterData(20, 25, 25, 10, true),
                            backgroundColor: 'rgba(52, 152, 219, 0.8)',
                            pointRadius: (d) => 3 + d.r * 5,
                            pointHoverRadius: 8
                        },
                        // 物品节点
                        {
                            label: '物品',
                            data: generateClusterData(30, 25, 25, 5, false, 10, 40),
                            backgroundColor: 'rgba(231, 76, 60, 0.8)',
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { min: 0, max: 50, display: false },
                        y: { min: 0, max: 50, display: false }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '社交推荐异构网络示意图'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) {
                                        return `用户: U${context.dataIndex + 1}, 粉丝数: ${Math.round(context.raw.r * 50)}`;
                                    } else {
                                        return `物品: I${context.dataIndex + 1}`;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // 社交网络指标图表
            const socialMetricsCtx = document.getElementById('socialMetricsChart').getContext('2d');
            new Chart(socialMetricsCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '用户',
                        data: generateCorrelatedData(50, 1, 10, 0.7),
                        backgroundColor: 'rgba(52, 152, 219, 0.6)',
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { 
                            title: { display: true, text: '用户活跃度（交互数量）' },
                            min: 0 
                        },
                        y: { 
                            title: { display: true, text: '社交影响力（被关注数量）' },
                            min: 0 
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '用户活跃度与社交影响力的关系'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `活跃度: ${Math.round(context.raw.x)}, 影响力: ${Math.round(context.raw.y)}`;
                                }
                            }
                        }
                    }
                }
            });

            // 社交模型图表
            const socialModelCtx = document.getElementById('socialModelChart').getContext('2d');
            new Chart(socialModelCtx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 21}, (_, i) => i),
                    datasets: [{
                        label: 'α = 0.1 (弱社交影响)',
                        data: [0.2, 0.22, 0.24, 0.25, 0.26, 0.27, 0.28, 0.28, 0.29, 0.29, 0.30, 
                               0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30],
                        borderColor: 'rgba(52, 152, 219, 1)',
                        tension: 0.3
                    }, {
                        label: 'α = 0.5 (中等社交影响)',
                        data: [0.2, 0.35, 0.45, 0.52, 0.57, 0.60, 0.62, 0.64, 0.65, 0.66, 0.67, 
                               0.67, 0.68, 0.68, 0.68, 0.68, 0.68, 0.68, 0.68, 0.68, 0.68],
                        borderColor: 'rgba(46, 204, 113, 1)',
                        tension: 0.3
                    }, {
                        label: 'α = 0.9 (强社交影响)',
                        data: [0.2, 0.50, 0.68, 0.78, 0.84, 0.88, 0.90, 0.92, 0.93, 0.94, 0.94, 
                               0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95],
                        borderColor: 'rgba(231, 76, 60, 1)',
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: '时间步' } },
                        y: { 
                            title: { display: true, text: '用户偏好度' },
                            min: 0, 
                            max: 1.0 
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '不同社交影响强度下的用户偏好演化'
                        }
                    }
                }
            });

            // 社交解决方案图表
            const socialSolutionCtx = document.getElementById('socialSolutionChart').getContext('2d');
            new Chart(socialSolutionCtx, {
                type: 'bar',
                data: {
                    labels: ['基于内容', '协同过滤', '矩阵分解', '社交推荐', '混合模型'],
                    datasets: [{
                        label: '准确率 (RMSE)',
                        data: [0.98, 0.85, 0.80, 0.72, 0.68],
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                        yAxisID: 'y'
                    }, {
                        label: '覆盖率 (%)',
                        data: [85, 70, 75, 82, 88],
                        backgroundColor: 'rgba(231, 76, 60, 0.7)',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: '准确率 (RMSE, 越低越好)' },
                            min: 0.5,
                            max: 1.0
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: '覆盖率 (%)' },
                            min: 50,
                            max: 100,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '不同推荐算法的性能比较'
                        }
                    }
                }
            });

            // 比较图表
            const comparisonCtx = document.getElementById('comparisonChart').getContext('2d');
            new Chart(comparisonCtx, {
                type: 'bar',
                data: {
                    labels: ['幂律指数', '平均聚类系数', '平均路径长度', '模块化程度'],
                    datasets: [{
                        label: 'PPI网络',
                        data: [2.1, 0.58, 3.2, 0.72],
                        backgroundColor: 'rgba(52, 152, 219, 0.7)',
                    }, {
                        label: '社交推荐网络',
                        data: [2.7, 0.42, 4.5, 0.65],
                        backgroundColor: 'rgba(231, 76, 60, 0.7)',
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: false, title: { display: true, text: '指标值' } }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'PPI网络与社交推荐网络的关键指标比较'
                        }
                    }
                }
            });

            // 未来趋势图表
            const futureTrendsCtx = document.getElementById('futureTrendsChart').getContext('2d');
            new Chart(futureTrendsCtx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: '图神经网络与网络智能',
                        data: [{x: 85, y: 90, r: 20}],
                        backgroundColor: 'rgba(52, 152, 219, 0.6)'
                    }, {
                        label: '动态网络分析',
                        data: [{x: 75, y: 85, r: 18}],
                        backgroundColor: 'rgba(231, 76, 60, 0.6)'
                    }, {
                        label: '多层网络研究',
                        data: [{x: 70, y: 80, r: 16}],
                        backgroundColor: 'rgba(46, 204, 113, 0.6)'
                    }, {
                        label: '大规模网络计算',
                        data: [{x: 65, y: 75, r: 14}],
                        backgroundColor: 'rgba(155, 89, 182, 0.6)'
                    }, {
                        label: '网络可控性',
                        data: [{x: 60, y: 70, r: 12}],
                        backgroundColor: 'rgba(241, 196, 15, 0.6)'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { 
                            title: { display: true, text: '发展速度 (%)' },
                            min: 50, 
                            max: 100 
                        },
                        y: { 
                            title: { display: true, text: '应用潜力 (%)' },
                            min: 50, 
                            max: 100 
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '复杂网络研究未来趋势预测'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: 发展速度=${context.raw.x}%, 应用潜力=${context.raw.y}%`;
                                }
                            }
                        }
                    }
                }
            });
        });

        // 辅助函数：生成聚类数据
        function generateClusterData(count, centerX, centerY, spread, useDegree = false, xRange = 50, yRange = 50) {
            const data = [];
            for (let i = 0; i < count; i++) {
                const x = centerX + (Math.random() - 0.5) * spread;
                const y = centerY + (Math.random() - 0.5) * spread;
                // 确保点在范围内
                const clampedX = Math.max(0, Math.min(xRange, x));
                const clampedY = Math.max(0, Math.min(yRange, y));
                
                // 生成度值（0-1之间）
                const degree = useDegree ? Math.random() : 0.5;
                
                data.push({x: clampedX, y: clampedY, r: degree});
            }
            return data;
        }

        // 辅助函数：生成具有相关性的数据
        function generateCorrelatedData(count, min, max, correlation) {
            const data = [];
            const range = max - min;
            
            for (let i = 0; i < count; i++) {
                // 生成x值
                const x = min + Math.random() * range;
                
                // 生成与x相关的y值
                const baseY = min + (x - min) * (range / range) * correlation;
                const noise = (Math.random() - 0.5) * range * (1 - correlation);
                const y = Math.max(min, Math.min(max, baseY + noise));
                
                data.push({x, y});
            }
            
            return data;
        }
    </script>
</body>
</html>
    